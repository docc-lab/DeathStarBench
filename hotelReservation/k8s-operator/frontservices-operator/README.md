# Building and Deploying a Kubernetes Operator for Frontend Service in hotelReservation

## Prerequisites
0. Using our lab hotelReservation cloudlab profile to create an experiment, and ssh into node 0.

1. Install Go (version 1.23.0)

    ```bash
    wget https://go.dev/dl/go1.23.0.linux-amd64.tar.gz
    sudo tar -C /usr/local -xzf go1.23.0.linux-amd64.tar.gz

    export PATH=$PATH:/usr/local/go/bin
    ```

2. Install Operator SDK 1.28

    ```bash
    export ARCH=$(case $(uname -m) in x86_64) echo -n amd64 ;; aarch64) echo -n arm64 ;; *) echo -n $(uname -m) ;; esac)
    export OS=$(uname | awk '{print tolower($0)}')

    export OPERATOR_SDK_DL_URL=https://github.com/operator-framework/operator-sdk/releases/download/v1.36.1
    curl -LO ${OPERATOR_SDK_DL_URL}/operator-sdk_${OS}_${ARCH}

    chmod +x operator-sdk_${OS}_${ARCH} && sudo mv operator-sdk_${OS}_${ARCH} /usr/local/bin/operator-sdk
    ```

3. Install controller runtime v0.14.1 and controller-gen v0.16.0

    ```bash
    go install sigs.k8s.io/controller-tools/cmd/controller-gen@v0.16.0
    go install sigs.k8s.io/controller-runtime@latest

    export PATH=$PATH:$(go env GOPATH)/bin
    ```

## Step 1: Create the Operator Project

Find the operator go project dir, in our case, checkout to operator branch of lab forked DSB--all necessary code are inside.
The operator's src dir structure is created using operator sdk (see details in below optional subsection).
There are other yaml files inside `.../frontservices-operator` I created for deploying operator later.

```bash
cd /local/DeathStarBench/
git checkout operator

cd hotelReservation/k8s-operator/frontservices-operator/src
```

(Optional) If you want to create another operator project, create a new dir then do the following:
```bash
# Optional
mkdir <new-operator-dir> & cd <new-operator-dir>

go mod init
operator-sdk init
operator-sdk create api --group <mygroup> --version v1 --kind <MyResource> --resource --controller
```

## Step 2: Implement the Operator Logic

Empty controller and CR file is generated by the operator sdk call in step 1. I only added basic skeleton to both allowing build for the purpose of this tutorial.
**There is nothing you need to add for just walking through this tutorial, so skip to step 3.**

(Optional) If you want to add real controlling logic, you may refer to [a description I wrote](https://docs.google.com/document/d/1KdbMYFOp8f_yNp30twyzo0VSS77On2cMT6Y-wAfc-VM/edit?usp=sharing) to implement it.

1. Define your Custom Resource (CR) in `api/v1/myresource_types.go`
2. Implement reconciliation logic in `controllers/myresource_controller.go`

## Step 3: Update Dependencies

```bash
cd hotelReservation/k8s-operator/frontservices-operator/src

go mod tidy
go mod vendor
```

## Step 4: Generate Code and Manifests

```bash
make generate
make manifests
```

## Step 5: Build the Operator Image
If you already pushed the image, skip to step 7.

```bash
make docker-build IMG=<your-registry>/<your-image-name>:<your-image-tag>
```

## Step 6: Push the Operator Image

```bash
make docker-push IMG=<your-registry>/<your-image-name>:<your-image-tag>
```

## Step 7: Deploy the Operator

In our case, I already prepared the deployment.yaml for operator. So, go ahead to apply it with kubectl

But, we need to do the following before applying it: 
- create a namespace for the operator pod
- apply those rbac (permission mechanism in k8s) and crd (custom resource definition) yamls
- update the docker image name inside deployment yaml


```bash
kubectl create namespace frontendservice-operator-system

cd /local/DeathStarBench/hotelReservation/k8s-operator/frontservices-operator

# define a role with necessary permission for operator
kubectl apply -f rbac/frontendservice-operator-role.yaml 
# bind above role to a namespace for operator
kubectl apply -f rbac/frontendservice-operator-rolebinding.yaml
# register serviceaccount for operator
kubectl apply -f rbac/frontendservice-operator-serviceaccount.yaml
# define our custom resource called frontendservice
kubectl apply -f crd/frontend.crd.yaml

# update docker image name in 
vim deployment/frontendservice-operator-system.yaml

# finally, apply the operator deployment
kubectl apply -f deployment/frontendservice-operator-deployment.yaml 
```

(Optional) Or alterantively, using Makefile generated from operator sdk to deploy without executing above cmd manaully. It requires a specific path of deployment.yaml though.
```bash
# Optional
make deploy IMG=<your-registry>/<your-image-name>:<your-image-tag>
```

## Step 8: Verify the Deployment

```bash
kubectl get deployment -n frontendservice-operator-system
kubectl get pods -n frontendservice-operator-system
```

## Step 9: Create a Custom Resource
CR yamls are instances of corresponding CRD. If you take a look at a CRD, for example `.../frontservices-operator/crd/frontend.crd.yaml`, you'll find there are properties variable defined under spec. Creating a CR yaml with the kind of the CRD, you give specific value for different properties that allows controller to monitor and react.

Find our CR yaml file for our custom resource (frontendservice) and apply it:

```bash
kubectl apply -f /local/DeathStarBench/hotelReservation/kubernetes/frontend/my-frontendCR.frontend.yaml
```

(Optional) If you working on a new operator project, you may refer to [a description I wrote](https://docs.google.com/document/d/1KdbMYFOp8f_yNp30twyzo0VSS77On2cMT6Y-wAfc-VM/edit?usp=sharing) along with pervious controller logic.

## Step 10: Verify the Custom Resource

```bash
kubectl get FrontendService
```

## Others: Check Operator Logs & Uninstall the Operator

```bash
kubectl logs -f frontendservice-operator-f858b748b-kslhx -n frontendservice-operator-system

make undeploy
```